# Lab-7_202001023

# Lab-7_202001023

# **Section A**

## **We can identify the following equivalence classes:** <br>

1. Valid dates: such as (11, 5, 1999).
2. Invalid dates: such as (31, 2, 2010) or (31, 4, 1920).
3. Out of range dates: such as (0, 7, 2012) or (5, 13, 2005).
Based on these equivalence classes, we can design the following test cases:

**Input Data and Expected Outcome**<br>

**Valid dates:**<br>
| Current date     | Previous date     |
| ------------- | :---: |
| 15, 10, 2022 | 14, 10, 2022 |
| 1, 1, 2015 | 31, 12, 2014 |
| 31, 3, 2000 | 30, 3, 2000|

**Invalid dates:**<br>

| Current date |
| ------------- |
| 29, 2, 2022 |
| 31, 4, 2010 | 
| 30, 2, 2000 | 

**Out of range dates:**<br>

| Current date |
| ------------- |
| 0, 5, 2010 |
| 15, 13, 2005 | 
| 31, 12, 1899 | 

## **Boundary Value Analysis:**<br>

1) The earliest possible date: (1, 1, 1900)
2) The latest possible date: (31, 12, 2015)
3) The earliest day of each month: (1, 1, 2000), (1, 2, 2000), (1, 3, 2000),..., (1, 12, 2000)
4) The latest day of each month: (31, 1, 2000), (28, 2, 2000), (31, 3, 2000),..., (31, 12, 2000)
5) Leap year day: (29, 2, 2000)
6) Invalid leap year day: (29, 2, 1900)
7) One day before earliest date: (31, 12, 1899)
8) One day after latest date: (1, 1, 2016)<br>

Based on these boundary test cases, we can design the following test cases:<br><br>
Tester Action and Input Data Expected Outcome<br>

**Boundary Test Cases:**<br>

| Input | Output |
| ------------- | :---: |
| 1, 1, 1900 | Invalid |
| 31, 12, 2015 | 30, 12, 2015 |
| 1, 1, 2000 | 31, 12, 1999 |
| 31, 1, 2000 | 30, 1, 2000 |
| 29, 2, 2000 | 28, 2, 2000 |
| 29, 2, 1900 | Invalid |
<br>

## Program 1:
The function linearSearch searches for a value v in an array of integers a. <br>
If v appears in the array a, then the function returns the first index i, such that a[i] == v; otherwise, -1 is returned.<br>
```cpp
int linearSearch(int v, int a[])
{
  int i = 0;
  while (i < a.length)
  {
    if (a[i] == v)
    return(i);
    i++;
  }
  return (-1);
}
```

**Equivalence Partitioning:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| v is present in a        | Index of v         |
| v is not present in a         | -1         |

**Boundary Value Analysis:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| Empty array a        | -1         |
| v is present at the first index of a         | 0         |
| v is present at the last index of a length of a        | -1         |
| v is not present in a         | -1         |
<br>

## Program 2:
The function countItem returns the number of times a value v appears in an array of integers a.<br>
```cpp
int countItem(int v, int a[])
{
  int count = 0;
  for (int i = 0; i < a.length; i++)
  {
    if (a[i] == v)
    count++;
  }
return (count);
}
```

**Equivalence Partitioning:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| v is present in a        | Number of times v appears in a         |
| v is not present in a         | 0         |

**Boundary Value Analysis:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| Empty array a        | 0         |
| v is present once in a         | 1         |
| v is present multiple times in a        | Number of times v appears in a         |
| v is present at the first index of a         | 1         |
| v is present at the last index of a        | 1        |
| v is not present in a         | 0        |

<br>

## Program 3:
The function binarySearch searches for a value v in an ordered array of integers a. <br>
If v appears in the array a, then the function returns an index i, such that a[i] == v; otherwise, -1 is returned.<br>
Assumption: the elements in the array a are sorted in non-decreasing order.<br>
```cpp
int binarySearch(int v, int a[])
{
  int lo,mid,hi;
  lo = 0;
  hi = a.length-1;
  while (lo <= hi)
  {
    mid = (lo+hi)/2;
    if (v == a[mid])
      return (mid);
    else if (v < a[mid])
      hi = mid-1;
    else
      lo = mid+1;
  }
  return(-1);
}
```

**Equivalence Partitioning:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| v is present in a        | Index of v         |
| v is not present in a         | -1         |

**Boundary Value Analysis:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| Empty array a        | -1         |
| v is present at the first index of a         | 0         |
| v is present at the last index of a length of a        | -1         |
| v is not present in a         | -1         |

<br>

## Program 4:
P4. The following problem has been adapted from The Art of Software Testing, by G. Myers (1979). <br>
The function triangle takes three integer parameters that are interpreted as the lengths of the sides of a triangle. <br>
It returns whether the triangle is equilateral (three lengths equal), isosceles (two lengths equal), scalene (no lengths equal), or invalid (impossible lengths).<br>

```cpp
final int EQUILATERAL = 0;
final int ISOSCELES = 1;
final int SCALENE = 2;
final int INVALID = 3;
int triangle(int a, int b, int c)
{
  if (a >= b+c || b >= a+c || c >= a+b)
    return(INVALID);
  if (a == b && b == c)
    return(EQUILATERAL);
  if (a == b || a == c || b == c)
    return(ISOSCELES);
   return(SCALENE);
}
```

**Equivalence Partitioning:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| Invalid triangle (a+b<=c)        | INVALID         |
| Valid equilateral triangle (a=b=c)         | EQUILATERAL         |
| Valid isosceles triangle (a=b<c)        | ISOSCELES         |
| Valid scalene triangle (a<b<c)         | SCALENE         |

**Boundary Value Analysis:**

| Tester Action and Input Data     | Expected Outcome      |
| ------------- | :---: |
| Invalid triangle (a+b<=c)        | INVALID         |
| Invalid triangle (a+c<b)         | INVALID         |
| Invalid triangle (b+c<a)        | INVALID         |
| Valid equilateral triangle (a=b=c)         | EQUILATERAL         |
| Valid isosceles triangle (a=b<c)        | ISOSCELES         |
| Valid isosceles triangle (a=c<b)        | ISOSCELES         |
| Valid isosceles triangle (b=c<a)        | ISOSCELES         |
| Valid scalene triangle (a<b<c)         | SCALENE         |
| Valid scalene triangle (a<c<b)         | SCALENE         |
| Valid scalene triangle (b<a<c)         | SCALENE         |
| Valid scalene triangle (b<c<a)         | SCALENE         |
| Valid scalene triangle (c<a<b)         | SCALENE         |
| Valid scalene triangle (c<b<a)         | SCALENE         |

<br>

